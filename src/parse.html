<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>


<script>
let count = 0

let source = `asdfsd<div  {x} {x+y/z}   {...y} test='123' id="123"  {x + y / 2} on:click={() => \`kdjk a}} s ${{x: 10}.x}dk\`}>askldfjalskjdflksd</div>`
let lastParser = parse


function dispatch(type, value) {
  // console.table({[type]: value})
  console.log(type, value)
}

const $repeat = (...args) => (...until) => {
  if (!source) return

  if (count++ > 100) {
    throw new Error("max circular")
  }

  const concated = args.concat(until)
  const re = new RegExp("^(?:" + concated.map(arg => arg[1].source).join("|") + ")")

  while (source) {
    const m = re.exec(source)
    if (!m) {
      throw new Error("invalid. " + source + " " + re)
    }

    source = RegExp.rightContext

    const index = m.slice(1).findIndex(arg => arg !== undefined)
    const target = concated[index]

    const [type, reg, next, isSkip] = target

    !isSkip && dispatch(type, m[0])
    next && next()

    if (index >= args.length) break
    if (until.length === 0) break
  }
}


const ws = ["(ws)", /(\s+)/, null, true]


/// root
const comment = ["(comment)", /(<!--)/, parse]
const rawTextStartTags = ["(rawTextStartTags)", /<(script|style)(?=[\s>])/, rawTextElement]
const startTags = ["(startTag)", /<([^\s\/>]+)/, attrs]
const endTags = ["(endTags)", /<\/([^>\s]+)[^>]*>/, parse]
const characters = ["(characters)", /([^<{]+)/, parse]


/// attr
const attrName = ["(attrName)", /([^\s"'<>=/{]+)/, attr]
const attrOperator = ["=", /(\s*=\s*)/, attrValue]
const attrEnd = ["(attrEnd)", /(\/>|>)/, parse]


/// attrValues
const unquoted = ["(unquoted)", /([^\s?"'=<>`{]+)/]

const string1Start = ["(string1Start)", /(")/, string1]
const string1Characters = ["(string1Characters)", /([^"]+)/]
const string1End = ["(string1End)", /(")/]

const string2Start = ["(string2Start)", /(')/, string2]
const string2Characters = ["(string2Characters)", /([^']+)/]
const string2End = ["(string2End)", /(')/]

const interpolationStart = ["{", /({)/, interpolation]
const interpolationCharacters = ["(interpolationCharacters)", /([^"'`{}]+)/]
const interpolationEnd = ["(interpolationEnd)", /(})/]


/// js
const createEscapeOneLineRegexp = (open, close = open, ...blocks) => new RegExp(`${open}(?:${blocks.map(b => b + '|').join('')}\\\\.|[^\\\\${close}])*${close}`)
const re_js_string1 = createEscapeOneLineRegexp("'")
const re_js_string2 = createEscapeOneLineRegexp('"')
const re_js_string3 = createEscapeOneLineRegexp("`")

const js_string1 = ["(js/string1)", new RegExp('(' + re_js_string1.source + ')')]
const js_string2 = ["(js/string2)", new RegExp('(' + re_js_string2.source + ')')]
const js_string3 = ["(js/string3)", new RegExp('(' + re_js_string3.source + ')')]


function parse() {
  $repeat(comment, rawTextStartTags, startTags, endTags, characters, interpolationStart)()
}

function rawTextElement() {
  let startTag = RegExp.lastMatch
  let endTag = "</" + startTag.slice(1)
  let lastIndex = source.indexOf(endTag)

  dispatch("text", source.slice(0, lastIndex))
  source = source.slice(lastIndex)
  parse()
}

function attrs() {
  $repeat(ws, attrName, interpolationStart)(attrEnd)
}

function attr() {
  $repeat(attrOperator)()
}

function attrValue() {
  $repeat(unquoted, string1Start, string2Start, interpolationStart)()
}

function string1() {
  $repeat(string1Characters)(string1End)
}

function string2() {
  $repeat(string2Characters)(string2End)
}

function interpolation() {
  $repeat(interpolationCharacters, js_string1, js_string2, js_string3)(interpolationEnd)
}


fetch("./App.svelte").then(res => res.text()).then(text => {
  source = text
  parse(source)
})


</script>
</body>
</html>